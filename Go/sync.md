## 除了Mutex还有哪些方式可以安全的读写共享数据
CSP、信号量、原子操作
## Go是如何实现原子操作的
在CPU层面实现，CPU硬件识别原子操作的函数，编译时加上LOCK标记，执行的时候CPU层面禁止该缓存块被读取
## 原子操作和锁的区别
主要是数据和底层的差异：
- 原子操作对单个变量，锁对一段数据操作
- 原子操作的底层时CPU硬件层面，锁则是涉及到阻塞唤醒性能差
  
## mutex底层是如何实现的
### 数据结构
- state 29位g数量，1位是否有锁，1位是否饥饿，1位是否有g自旋等待
- sema 作为key，将g封装为sudog插入平衡二叉树中

## mutex的模式
- 饥饿模式：新的g直接自旋尝试获取锁，因为有缓存，吞吐量大
- 公平模式：g超过1ms等待以后进入，强制先进先出

## 自旋的规则
- 多核CPU
- 非饥饿模式
- 无其他自旋的

## Mutex 已经被一个 Goroutine 获取了, 其它等待中的 Goroutine 们只能一直等待。那么等这个锁释放后，等待中的 Goroutine 中哪一个会优先获取 Mutex 呢?
看情况。饥饿还是公平模式

## sync.once是什么
保证一段逻辑只被执行一次。配置加载、初始化、全局变量都可以使用。

## sync.once的原理是什么
数据结构：mutex+done
检查是否done==0否的话已经被使用过了。
加锁，继续检查，避免加锁过程中被修改了。
执行逻辑，释放锁。  
后续再次执行如果已经不为0说明已经执行过，直接返回。
## WaitGroup
用于多个等待多个g完成，  
数据结构：
- sema
- state

操作：
- add
- done
- wait

## sync.map的原理
### 数据结构
- count
- missed
- read
  - bucket
  - 是否有新增
- dirty
  - bucket
 
### 重建
- dirty重建
- read重建

### 删除
read中设置为nil

## 为什么要设计nil和expunged两种删除状态？
read是只读的，为了性能考虑，减少一次修改就全量复制

## sync.Map 使用场景
读多写少的场景，缓存等
