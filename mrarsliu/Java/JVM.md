## JVM的内存模型介绍一下
- 虚拟机栈
- 本地方法栈
- 堆
- 直接内存
- 元空间
- 程序计数器

## 运行时常量池&&常量池

## 元空间/永久代各自存放什么，为什么要变

## 方法调用的流程

## JVM中的堆和栈区别

## 栈中存的是指针还是对象

## 堆分为哪些区域

## 大对象放在哪里

## 程序计数器的作用

## 方法区方法执行的过程

## 方法区有什么

## String保存在哪里

## String s = new("abc")的创建过程

## 字符串常量池在什么位置
- jdk1.6
- jdk1.7
- jdk1.8

## 引用类型有哪些
- 短期元数据
- 对象销毁前通知
- 
## 弱引用了解吗

## 内存泄露和内存溢出了解吗

## 堆溢出？

## 栈溢出

## 实际的场景和处理方式
- 静态属性
- 资源释放
- threadLocal

## 字节码文件
- 魔数
- 版本号
- 常量池
- 访问标志
- 父类、接口
- 字段表
- 方法表
javap/idea插件
## 对象的内存结构
- 对象头
  - markwork
  - 类型指针
  - 数组长度
- 对象体
- 内存对齐

## 类加载过程
- 加载
- 链接
  - 验证
  - 准备
  - 解析
- 初始化
## 双亲委派机制

## 打破双亲委派机制的场景
- Tomcat——需要类库隔离，热更新
- SPI——sql接口在系统类加载器，实现在应用加载器，需要加载一个线程加载器帮助加载
## 类加载器有哪些
- 系统——C++实现，负责核心类库《String、util》
- 扩展——负责JDK拓展类库《javax》
- 应用程序——自己class路径中的、第三方jar包
- 自定义————mysql、网络
## 对象的生命周期
创建——使用——销毁
## 对象的创建过程
- 类加载检查 双亲委派机制
- 分配内存空间（按照垃圾回收器决定）
  - 内存指针
  - 内存列表
  - 并发安全：CAS/TLAB（Eden区域提前分配私有内存）
- 赋零值
  - 直接访问
  - 安全性
- 设置对象头
  - 年代+code+锁状态
- init
  - 这里JVM将this、super、构造方法收敛，为一个init
  - 先父后子，先静后对象
## 垃圾回收是什么，什么是垃圾
## 如何除法垃圾回收
## 判断垃圾的方法有哪些？
## minorGC、marjorGC、FULLGC
- minor，年轻代频繁发生
- marjor，老年代，主要是晋升过快和老年代不足
- full，全部（新老方法区），方法区不足，手动，无法放入老年代

## 常见的垃圾回收算法和垃圾回收器
- PS/PO
- parnew/CMS
- Serial
- G1
## GMS选择标记清除的原因以及缺点
标记清除
1. 简单，延迟低
2. 对比标记整理复制和修改引用的时间长，STW和GMS的初衷违背
带来的问题：
1. 内存碎片
2. CPU压力大
3. 标记清理阶段还会继续运行，产生的垃圾无法回收
## CMS的过程、优势、缺点
- 初始标记 静态变量、常量、栈变量、年轻代变量
- 并发标记 维护一个卡表将新的关系变化放入卡表中，另外新的引用和引用修改会被记录
- 最终标记 根据上面的产物STW重新标记
- 并发清除 ——安全：不参与物理隔离

## 漏标和多标问题
漏标则会错误清楚，JVM hotspot采用了写屏障处理：并发标记阶段用户线程会触发卡表标记并且放入，最终标记阶段会将
多标放入下一轮处理，出现浮动垃圾  

## G1的目的、特点
大堆，可预测的回收时间  
逻辑分区，Region
## G1的年轻代
复制算法，STW，照圣母思，快，存货少，多线程执行
## 并发标记
1. 初始停顿，记录快照
2. 并发标记，SATB，另外卡表优化
3. 最终标记
4. 分析评估，给出Cset
5. 混合清理
