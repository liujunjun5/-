## 设计模式的六大法则
- 里氏代换 子类可以完全有父类替代，要求子类实现父类的所有方法，且不修改父类的实现  正方形的例子
- 最小知道法则 应该只和朋友通信（成员变量、方法、参数）
- 依赖倒置 依赖于抽象而不是实现
- 接口隔离 接口要最小，可以拆分出
- 单一职责  专注于单一的功能，避免臃肿 举例子 内容发布系统，有一个 Article类处理文章本身的数据和操作，持久化、内容展示、格式转换不应该出现
- 开闭原则 对扩展开放，对修改关闭， 反例ifelse——正例抽象出接口，每一次继承拓展

## 重载和重写的区别

## 抽象类和普通类有社么区别
抽象类abstract修饰符，可以不实现方法，代表抽象，共性，无法被final修饰，无法直接实例化  
## 接口和抽象类的区别
共性：抽象、共性  接口偏向于行为，抽象类侧重类的继承关系  多继承 关键字  
抽象类的成员变量可以是静态、实例常量，接口只能是静态常量    

## 静态内部类和非静态内部类的区别

## 非静态内部类为什么可以访问类的方法

## final的作用
- 类
- 方法
- 属性

## static的作用
- 变量
- 方法
- 代码块
- 内部类

## 深拷贝和浅拷贝的区别

## 深拷贝的实现方式
- 实现clone方法
- 序列化反序列化

## 泛型是社么

## 泛型擦除是社么，历史背景

## BIO、NIO、AIO
- 同步阻塞、非同步阻塞、异步io
- 等待数据到来，wait、notify
- selector监听channel，将数据从缓冲区copy
- 利用操作系统完成io，最后通知java

## Reactor && Proactor
- Reactor 操作系统完成通知，应用程序完成读写；Proactor 应用程序异步发起io请求，交给操作系统完成以后通知应用程序
- window选择r——api简单、企业使用；linux使用p———Unix提供工具开放；Redis使用r———io不是瓶颈，内存和CPU才是，单线程，linux

## 排序的方式
- 实现Comparactor接口CompareTo方法，配合Collections.sort
- 创建自定义排序类，Compartor类，lamdba简化，sort链式

## native、JNI、JIT、Java、OS线程、JVM
- native本地方法，C/C++编写的代码，JNI进行管理和调用
- JIT是热点优化技术，对于频繁使用的代码，JVM会进行优化具体表现是机器码
- JVM创建的线程本质上就是操作系统线程，JVM也是一个进程，内存管理、io调用C
