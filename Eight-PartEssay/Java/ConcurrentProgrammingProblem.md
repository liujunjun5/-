# 多线程
## Java的内存模型(JMM)
JMM是专门解决多线程并发问题的一套规则。简单说，就是规定了多线程环境下，线程怎么访问共享变量才能不出错，核心是处理可见性、原子性、有序性这三个问题。

JMM的核心思路是：定义主内存(大家共享的内存)和工作内存(每个线程自己的缓存)，规定变量必须从主内存加载到工作内存才能操作，改完再写回主内存。

然后通过volatile、synchronized这些关键字，控制加载、写回的时机，以及禁止不合理的指令重排，最终保证多线程操作共享变量时能正确交互。



## Java多线程是什么？需要注意什么？
Java多线程是指在一个Java程序中同时运行多个线程，这些线程共享程序的内存空间(如全局变量、方法区等)，但有各自的栈和程序计数器，能同时执行不同的任务，比如一个线程处理用户输入，另一个线程后台下载文件，提升程序效率。

使用Java多线程需要注意一下几点：

+ 首先是线程安全问题。多个线程同时操作共享数据时，可能出现错误。比如两个线程同时给一个变量加1，原本该加2，结果可能只加了1，这是因为线程切换时没做好数据保护。需要synchronized关键字、Lock锁等方式，保证同一时间只有一个线程操作共享数据
+ 其次是线程间通信。线程需要协作时，比如一个线程产生数据，另一个线程消费数据，要通过wait()、notify()等方法控制，避免出现一方没准备好，另一方就操作的情况，否则可能导致数据错误或线程无线等待。
+ 然后是线程的创建和销毁成本。频繁创建和销毁线程会消耗系统资源，影响性能。可以用线程驰管理线程，提前创建好一定数量的线程，重复使用，减少资源消耗。



## Java里面的线程和操作系统的流程一样吗？
Java底层会调用pthread_create来创建线程，所以本质上Java程序创建的线程，就是和操作系统线程是一样的，是1对1的线程模型。



## 使用多线程需要注意哪些问题？
要保证多线程的程序是安全的，不要出现数据竞争造成的数据混乱的问题。

Java的线程安全体现在一下三个方面：

+ 原子性：互斥访问，即同一时刻只能有一个线程对数据进行操作，在Java中使用了atomic包和synchronized关键字来确保原子性；
+ 可见性：一个线程对主内存的修改可以及时地被其他线程看到，在Java中使用了synchronized和volatile这两个关键字确保可见性
+ 有序性：一个线程观察其他线程中的指令顺序，由于指令重排序，该观察结果一般杂乱无序，在Java中使用了happens-before原则来确保有序性



## 保证数据的一致性有哪些方案呢？
+ 事务管理管理：使用数据库事务来确保一组数据库操作要么全部成功提交，要么全部失败回滚。通过ACID(原子性、一致性、隔离性、持久性)属性，数据库事务可以保证数据的一致性。
+ 锁机制：使用锁来实现对共享资源的互斥访问。在Java中，可以使用synchronized关键字、ReentrantLock或其他锁机制来控制并发访问，从而避免并发操作导致数据不一致。
+ 版本控制：通过乐观锁的方式，在更新数据时记录数据的版本信息，从而避免同时对同一数据进行修改，进而保证数据的一致性。



## 线程的创建方式有哪些？
1. 继承Thread类：用户自定义类继承java.lang.Thread类，重写其run()方法，run()方法中定义了线程执行的具体任务。创建给类的实例后，通过调用start()方法启动线程。
    1. 优点：编写简单，可直接使用this获得当前线程，无需使用Thread.currenttThread()方法。
    2. 缺点：因为线程类已经继承了Thread类所以不能再继承其他的父类
2. 实现Runnable接口：类可以通过实现java.lang.Runnable接口。而实现Runnable接口需要重写run()方法，然后将此Runnable对象作为参数传递给Thread类的构造器，创建Thread对象后调用其start()方法启动线程。
    1. 优点：线程类只是实现了Runnable接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。
    2. 缺点：编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法。
3. 实现Callable接口与FutureTask：java.util.concurrent.Callable接口类似于Runnable，但Callable的call()方法可以有返回值并可以抛出异常。要执行Callable任务，需将它包装进一个FutureTask，因为Thread类的构造器只接受Runnable参数，而FutureTask实现了Runnable接口。
    1. 缺点：编程稍微复杂，如果需要访问当前线程，必须调用Thread.currentThread()方法。
    2. 优点：线程只是实现Runnable或实现Callable接口，还可以继承其他类。这种方式下，多个线程可以共享一个target对象，非常适合多线程处理同一份资源的情形。
4. 使用线程池(Executor框架)：从Java5开始引入的java.util.concurrrent.ExecutorService和相关类提供了线程池的支持，这是一种更高效的线程管理方式，避免了频繁创建和销毁线程的开销。可以通过Executors类的静态方法创建不同类型的线程池。
    1. 缺点：线程池增加了程序的复杂度，特别是当涉及线程池参数调整和故障排查时。错误的配置可能导致死锁、资源耗尽等问题，这些问题的诊断和修复可能较为复杂
    2. 优点：线程池可以重用预先创建的线程，避免了线程创建和销毁的开销，显著提高了程序的性能。对于需要快速响应的并发请求，线程池可以迅速提供线程来处理任务，减少等待时间。并且，线程池能够有效控制运行的线程数量，防止因创建过多线程导致的系统资源耗尽(如内存溢出)。通过合理配置线程池大小，可以最大化CPU利用率和系统吞吐量。



## 怎么启动线程？
启动线程，通过Tread类的Start()



## 如何停止一个线程的运行
主要有这些方法：

+ 异常法停止：线程调用interrupt()方法后，在线程的run方法中判断当前对象的interrupt()状态，如果是中断状态则抛出异常，达到中断线程的效果。
+ 在沉睡中停止：现将线程sleep，然后调用interrupt标记中断状态，interrupt会将阻塞状态的线程中断。会抛出中断异常，达到停止线程的效果。
+ stop()暴力停止：线程调用stop()方法会被暴力停止，方法已弃用，该方法会有不好的后果；强制让线程停止有可能使一些请理性的工作得不到完成。
+ 使用return停止线程：调用interrupt标记为中断状态后，在run方法中判断当前线程状态，如果为中断状态则return，能达到停止线程的效果。



## 调用interrupt是如何让线程抛出异常的？
每个线程都有一个与之关联的布尔属性来表示其中断状态，中断状态的初始值为false，当一个线程被其他线程调用Thread.interrupt()方法中断时，会根据实际情况做出响应。

+ 如果该线程正在执行低级别的可中断方法(如Thread.sleep()、Thread.jion()或Object.wait())，则会解除阻塞并抛出InterruptedException异常。
+ 否则Thread.interrupt()仅设置线程的中断状态，在该被中断的线程中稍后可通过轮询中断状态来决定是否要停止当前正在执行的任务。



## Java线程的状态有哪些
| 线程状态 | 解释 |
| --- | --- |
| NEW | 尚未启动的线程状态，即线程创建，还未调用start方法 |
| RUNNABLE | 就绪状态（调用start，等待调度）+正在运行 |
| BLOCKED | 等待监视器锁时，陷入阻塞状态 |
| WAITING | 等待状态的线程正在等待另一线程执行特定的操作（如notify） |
| TIMED_WAITING | 具有指定等待时间的等待状态 |
| TERMINATED | 线程完成执行，终止状态 |




## sleep和wait的区别
对比列表

|  特性 | sleep()  | wait() |
| --- | --- | --- |
| 所属类 | Thread类(静态方法) | Object类(实例方法) |
| 锁释放 | ❌ | ✅ |
| 使用前提 | 任意位置调用 | 必须在同步块内(持有锁) |
| 唤醒机制 | 超时自动恢复 | 需要notify()/notifyAll()或超时 |
| 设计用途 | 暂时线程执行，不涉及锁协作 | 线程间协调，释放锁让其他线程工作 |


+ 所属分类的不同：sleep是Thread类的静态方法，可以在任何地方直接通过Thread.sleep()调用，无需依赖对象实例。wait是Object类的实例方法，这意味着必须通过对象实例来调用。
+ 锁释放的情况：Thread.sleep()在调用时，线程会暂停执行指定的时间，但不会释放持有的对象锁。也就是说，在sleep期间，其他线程无法获得该线程持有的锁。Object.wait()：调用该方法时，线程会释放持有的对象锁，进入等待状态，直到其他线程调用相同对象的notify()或notifyAll()方法唤醒它。
+ 使用条件：sleep可在任意位置调用，无需事先获取锁。wait必须在同步块或同步方法内调用(即线程需持有该对象的锁)，否则抛出IllegalMonitorStateException。
+ 唤醒机制：sleep休眠时间结束后，线程自动恢复到就绪状态，等待CPU调度。wait需要其他线程调用相同对象的notify()或notifyAll()方法才能被唤醒。notify()会随机唤醒一个在该对象上等待的线程，而notifyAll()会唤醒所有在该对象上等待的线程.



## sleep会释放cpu吗？
是的，调用Thread.sleep()时，线程会释放CPU，但不会释放持有的锁。

当线程调用sleep()后，会主动让出CPU时间片，进入TIMED_WAITING状态，此时操作系统会触发调度，将CPU分配给其他出于就绪状态的线程。这样其他线程(无论是需要同一锁的线程还是不相关线程)便有机会执行。

sleep()不会释放线程已持有的任何锁(如synchronized同步代码块或方法中获取的锁)。因此，如果有其他线程试图获取一把锁，它们仍会被阻塞，直到原线程退出同步代码块。



## blocked和waiting的区别
区别如下:

+ 触发条件：线程进入BLOCKED状态通常是因为试图获取一个对象的锁(monitor lock)，但该锁已经被另外一个线程持有。这通常发生在尝试进入synchronized块或方法时，如果锁已被占用，则线程将被阻塞直到锁可用。线程进入WAITING状态是因为它正在等待另一个线程执行某些操作，例如调用Object.wait()方法、Thread0jion()方法或者LockSupport.park()方法。在这种状态下，线程将不会消耗CPU资源，并且不会参与锁的竞争。
+ 唤醒机制：当一个线程被阻塞等待锁时，一旦锁被释放，线程将有机会重新尝试获取锁。如果锁此时未被其他线程获取，那么线程可以从BLOCKED状态变为RUNNABLE状态。线程在WAITING状态中需要被显示唤醒。例如，如果线程调用了Object.wait()，那么它必须等待另一个线程调用同一对象上的Object.notify()或Object.notifyAll()方法才能被唤醒。

故它们最大的区别有两个：

+ BLOCKED是锁竞争失败后被动触发的状态，WAITING是人为的主动触发的状态
+ BLOCKED的唤醒时自动触发的，而WAITTING状态是必须要通过特定的方法来主动唤醒



## wait状态下的线程如何进行恢复到running状态？
线程从等待(WAIT)状态恢复到运行(RUNNING)状态的核心机制是通过外部事件触发或资源可用性变化，比如等待的线程被其他线程对象唤醒，notify()和notifyAll()。



## notify和notifyAll的区别？
同样是唤醒等待的线程，同样最多只有一个线程能获得锁，同样不能控制那个线程获得锁。

区别在于：

+ 唤醒一个线程，其他线程依然出于wait的等待状态，如果被唤醒的线程结束时没调用notify，其他线程就永远没人去唤醒，只能等待超时，或者被中断。
+ notifyAll：所有线程退出wait的状态，开始竞争锁，但只有一个线程能抢到，这个线程执行完后，其他线程又会有一个幸运儿脱颖而出得到锁。



## notify选择那个线程
notify在源码的注释中说到notify选择唤醒的线程是任意的，但是依赖于具体实现的jvm。

JVM有很多实现，比较流行的就是hotspot，hotspot对notofy()的实现并不是我们以为的随机唤醒，而是"先进先出"的顺序唤醒。



## 不同的线程之间如何通信？
1. **<font style="color:rgb(15, 17, 21);">共享内存</font>**<font style="color:rgb(15, 17, 21);">：线程直接读写共享变量（需配合同步机制）。</font>
2. **<font style="color:rgb(15, 17, 21);">锁/互斥量</font>**<font style="color:rgb(15, 17, 21);">：防止数据竞争，确保线程互斥访问共享资源。</font>
3. **<font style="color:rgb(15, 17, 21);">条件变量</font>**<font style="color:rgb(15, 17, 21);">：让线程等待特定条件成立，常用于生产者-消费者模型。</font>
4. **<font style="color:rgb(15, 17, 21);">信号量</font>**<font style="color:rgb(15, 17, 21);">：控制同时访问资源的线程数量。</font>
5. **<font style="color:rgb(15, 17, 21);">消息队列/管道</font>**<font style="color:rgb(15, 17, 21);">：在线程间传递数据，解耦发送方和接收方。</font>
6. **<font style="color:rgb(15, 17, 21);">原子操作</font>**<font style="color:rgb(15, 17, 21);">：直接执行不可中断的读写，避免简单数据竞争。</font>

<font style="color:rgb(15, 17, 21);">关键点：</font>**<font style="color:rgb(15, 17, 21);">必须使用同步机制确保线程安全</font>**<font style="color:rgb(15, 17, 21);">，避免数据竞争和死锁。</font>



## 线程间通信方式有哪些？
1. Object类的wait()、notify()和notifyAll()方法
2. Lock和Condition接口。代码实现：

```plain
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class SharedResource {
    private final Lock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();

    public void consumer() throws InterruptedException {
        lock
.lock();
        try {
            while (/* 条件不满足 */) {
                condition
.await();
            }
            // 执行相应操作
        } finally {
            lock
.unlock();
        }
    }

    public void producer() {
        lock
.lock();
        try {
            // 执行相应操作
            condition
.signal(); // 或者 signalAll()
        } finally {
            lock
.unlock();
        }
    }
}
```

3. volatile关键字。
4. CountDownLatch。CountDownLatch是一个同步辅助类，它运行一个或多个线程等待其他线程完成操作。
5. CyclicBarrier。CyclicBarrier是一个同步辅助类，它允许一组线程相互等待，直到所有线程都到达某个公共屏障点
6. Semaphore。Semaphore是一个计数信号量，它可以控制同时访问特定资源的线程数量。



## 如何停止一个线程？
在Java中，停止线程的正确方式是通过协作式的逻辑控制线程终止，而非强制暴力终止（如已废弃的Thread.stop方法）。以下是实现安全停止线程的多种方法：

1. 通过共享标志位主动终止：定义一个可见的状态变量，有主线程控制其值，工作线程循环检测该变量以决定是否退出
2. 使用线程中断机制。通过使用Thread.Interrupt()触发线程中断状态，结合中断检测逻辑实现安全停止。
3. 通过Future取消任务。使用线程池提交任务，并通过Future.cancel()停止线程，依赖中断机制
4. 处理不可中断的阻塞操作。某些I/O或同步操作(如Socket.accept()、Lock.lock())无法通过中断直接响应。此时需结合资源关闭操作。比如，释放Socket释放阻塞。



## GO的协程和Java的线程有啥区别？
1. 首先最核心的区别是他们的调度模型不同：
    1. Java的线程是操作系统级别的线程，也就是内核线程，一个Java线程对应一个操作系统线程，它的创建、销毁、调度都是由操作系统内核来管理的。
    2. GO的协程，也就是goroutine，它是用户态的轻量级线程，是由Go运行时自己调度的，不需要经过操作系统内核。这就导致了很多后续的差异。
2. 从资源消耗上来说，差别非常明显：
    1. Java创建一个线程的开销是比较大的，默认情况下一个线程的栈空间大概是1MB左右，而且线程的创建和销毁都需要系统调用，开销不小。所以在Java里，不能无限制地创建线程，创建几千个线程系统可能就扛不住了，这也就是为什么Java里要用线程池来复用线程。
    2. Go的协程就轻量多了，一个goroutine初始化栈空间只有2KB，而且栈空间是可以动态伸缩的。Go里创建几万甚至几十万个协程都是很正常的事情。
3. 调度方式上也不太一样。
    1. Java线程的调度是抢占式的，由操作系统的调度器决定什么时候切换线程，线程切换需要保存和回复上下文，涉及到用户态和内核态的切换，这个开销比较大。
    2. Go的协程调度是在用户态完成的，Go运行时有个GMP模型，G就是goroutine，M是操作系统线程，P是逻辑处理器。Go会把多个协程映射到少量的操作系统线程上执行，协程的切换完全在用户态，不需要陷入内核，所以切换成本非常低。而Go的调度器会在协程发生阻塞的时候，比如IO操作或者channel操作时，自动把这个协程挂起，让其他协程继续执行，这种协作式调度非常高效。
4. 从使用方式上来讲，Go的协程使用起来十分简单。
    1. 在Go里创建一个协程只需要在函数调用前加个go关键字就行了，比如go doSomething()。
    2. 在Java里创建线程，要么需要new一个Thread对象，要么实现Runnable接口，或者用线程池，总之代码量要多一些。
5. 通信机制也有很大差异。
    1. Java线程之间通信主要靠共享内存，需要用synchronized、Lock这些同步机制来保证线程安全，还要小心处理死锁、竞态条件这些问题，写起来比较容易出错
    2. Go虽然也支持共享内存和锁，但它更提倡用channel来通信，有句话叫"不要通过共享内存来通信，而要通过通信来共享内存"。用channel的话，代码更清晰，也不容易出现并发问题。
6. 性能上来说，因为Go协程的轻量级特性和高效的调度器，在高并发场景下，Go的表现通常会更好。比如说要处理几万个并发请求，Java可能需要用复杂的异步框架或者线程池来优化，而Go直接为每个请求开一个协程就行了，代码简单性能还好。Java在企业级应用、生态完善性这些方面还是有很大优势的，但在并发模型的设计上，Go确实更现代化一些。















